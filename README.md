# RTL-Design-and-Synthesis-using-sky130

## Table of Contents

- [Day 1](#day-1)
  - [Introduction to open-source simulator iverilog](#introduction-to-open-source-simulator-iverilog)
  - [Labs using iverilog and gtkwave](#labs-using-iverilog-and-gtkwave)
  - [Introduction to Yosys and Logic synthesis](#introduction-to-yosys-and-logic-synthesis)
  - [Labs using Yosys and Sky130 PDKs](#labs-using-yosys-and-sky130-pdks)

- [Day 2](#day-2)
  - [Introduction to timing .libs](#introduction-to-timing-libs)
  - [Hierarchical vs Flat Synthesis](#hierarchical-vs-flat-synthesis)
  - [Various Flop Coding Styles and optimization](#various-flop-coding-styles-and-optimization)

- [Day 3](#day-3)
  - [Introduction to optimizations](#introduction-to-optimizations)
  - [Combinational logic optimizations](#combinational-logic-optimizations)
  - [Sequential logic optimizations](#sequential-logic-optimizations)
  - [Sequential optimizations for unused outputs](#sequential-optimizations-for-unused-outputs)

- [Day 4](#day-4)
  - [GLS, Synthesis-Simulation mismatch and Blocking/Non-blocking statements](#gls-synthesis-simulation-mismatch-and-blockingnon-blocking-statements)
  - [Labs on GLS and Synthesis-Simulation Mismatch](#labs-on-gls-and-synthesis-simulation-mismatch)
  - [Labs on synth-sim mismatch for blocking statements](#labs-on-synth-sim-mismatch-for-blocking-statements)

- [Day 5](#day-5)
  - [If Case constructs](#if-case-constructs)
  - [Labs on "Incomplete If Case"](#labs-on-incomplete-if-case)
  - [Labs on "Incomplete overlapping Case"](#labs-on-incomplete-overlapping-case)
  - [for loop and for generate](#for-loop-and-for-generate)
  - [Labs on "for loop" and "for generate"](#labs-on-for-loop-and-for-generate)
---
## Day 1
## Topic : Introduction to Verilog, Simulation, and Synthesis
# Tools Introduced : Icarus , GTKWave , Yosys
# Installation Commands (macOS – using Homebrew)

```bash
> brew install iverilog
> brew install gtkwave
> brew install yosys
```

### Introduction to open-source simulator iverilog

- Simulator: Tool to check our RTL Design(Implementation of a spec).
- Open-source Verilog simulation and compilation tool.
- Used to compile Verilog design files and generate simulation results.
- TestBench: Setup to apply stimulus to the design to check its functionality.
- GTKWave: Tool to view waveform output for the given inputs( to verify functionality).
- VCD file: Value Change Dump file/format.
- Simulator looks for the changes in the input and then dumps the changes to the output.

![Icarus Verilog Simulation Flow](images/simulation-flow.png)


### Labs using iverilog and gtkwave

- Environment Setup:

- Create a directory named VLSI.
  
```bash
> git clone https://github.com/kunalg123/sky130RTLDesignAndSynthesisWorkshop
```

VSD Workflow 

```bash

VLSI
.
├── sky130RTLDesignAndSynthesisWorkshop
   ├── DC_WORKSHOP
   │   ├── lib
   │   ├── README.md
   │   └── verilog_files
   ├── lib (library files)
   │   └── sky130_fd_sc_hd__tt_025C_1v80.lib (std cell library)
   ├── my_lib
   │   └── verilog_model (std cell verilog models)
   ├── README.md
   ├── verilog_files (lab experiments , testbench files)
   │   ├── good_mux.v
   │   ├── good_counter.v
   │   ├── bad_counter.v
   │   ├── tb_good_mux.v
   │   ├── tb_good_mux.vcd
   │           .
   │           .
   │           .
   └── yosys_run.sh
```

- Waveform viewer for displaying signal changes over time from simulation output.
- Used to analyze `.vcd` (Value Change Dump) files generated by simulations.

 ## Loading design to iverilog:

 Eg : good_mux.v tb_good_mux.v

Step 1: 
```bash
> iverilog design name.v testbench-associated.v
eg: > iverilog good_mux.v tb_good_mux.v
```
- A file will be generated:

```bash
a.out (file generated)
```
Step 2 : Execute a.out
```bash
> ./a.out
```
- A Vcd file will be generated. For this example:
```bash
tb_good_mux.vcd will be generated
```
Step 3: Load it to simulator

```bash
> gtkwave tb_good_mux.vcd
```
- View the waveform to check then input and output of the design.

## File structure/content lookup:

```bash
> gvim/vim (filename.v)
> gvim/vim good_mux.v
> gvim/vim tb_good_mux.v
```

### Introduction to Yosys and Logic synthesis

- Open-source framework for Verilog synthesis.
- Converts RTL designs into gate-level netlists.

Working:

Commands:

```bash
read_verilog : read design
read_liberty : read library
write_verilog : write out netlist
```

![Yosys Setup](images/yosys-setup.png)

## How to verify synthesis correctness?

- Having netlist (verilog code in terms of standard cells) and testbench (same as RTL Design's TestBench) , these being inputs for the simulator gives out the VCD file which can be used to verify using GTKWave.


![Yosys Synthesis Verification](images/synthesis-verify.png)

### Labs using Yosys and Sky130 PDKs : How to invoke Yosys and synthesize the design

To invoke yosys:

```bash

> yosys
```
![Yosys Command](images/yosys-command.png)

### Inside Yosys Prompt:

# 1. Command to read library:

```bash
> read_liberty -lib lib/sky130....lib
```
# 2. Command to read design:

```bash
> read_verilog filename.v
> read_verilog good_mux.v (example)
```
" Successfully finished Verilog Frontend." message should pop-up after the command.
```
> synth -top ( module needed to be synthesized)
> synth -top good_mux (example)
```
# 3. Command to generate netlist

```bash
> abc -liberty lib/sky....lib (convert RTL to gates accordinly from library)
```
ABC identifies the inputs and the cells used to build the design from the library.

# 4. Command for logic realised:

```
> show
```

# 5. Command to write netlist:

```
> write_verilog filename_netlist.v
> write_verilog good_mux_netlist.v (example)
```

```
write_verilog -noattr good_mux_netlist.v (simplified netlist)
```

---
## Day 2

## Topic : Timing libs, Hierarchical vs Flat Synthesis and Efficient Flop Coding Styles

### Introduction to timing .libs

- Library walk-through
 
## sky130_fc_sc_hd_tt_025C_1v80.lib is the library name

1. 130 - 130nm
2. tt - typical ( can be slow , fast or typical)
3. 025C - temperature
4. 1v8 - Voltage

## Important terminologies for a design to work

P V T
P - Process
V - Voltage
T - Temperature

Variations will be there according to PVT ( determines how Si is going to work)

Eg: CD Player produced and sold in Switzerland , Dubai , India
Dubai ( temp > 30 - 50c)
Switzerland (temp < 20 or maybe negative)
But CD Player should work irrespective of temp variations!

- There will be lot of cells in the library that has usage of multiple gates in multiple combinations.
- Has features of the cell (leakage power, area, power port info, transition , delay according to pins , timing information etc)
##  For example: cell("sky130_fd_sc_hd_and2_0")

- Two inputs - A and B (4 possible states) 
- Output - X
- 3 different areas are found w.r.t and2_0 , and2_2 , and 2_4

![PVT Variations](images/area-diff.png)

## Larger area => wider transistor usage
- Wider cells are faster but has large area and power usage.
## Smaller area => narrow transistor usage
- Narrow cells have delay more and area is less.

### Hierarchical vs Flat Synthesis

# example: multiple_modules.v
```
module sub_module2 (input a, input b, output y);
        assign y = a | b;
endmodule

module sub_module1 (input a, input b, output y);
        assign y = a&b;
endmodule

module multiple_modules (input a, input b, input c , output y);
        wire net1;
        sub_module1 u1(.a(a),.b(b),.y(net1));  //net1 = a&b
        sub_module2 u2(.a(net1),.b(c),.y(y));  //y = net1|c ,ie y = a&b + c;
endmodule

```
- module sub_module1 - AND gate (instantiated as u1)
- module sub_module2 - OR gate  (instantiated as u2)

![Multiple_Modules](images/multiple-modules.png)

# Synthesizing multiple_modules.v

```
> read_liberty -lib lib/sky....lib
> read_verilog multiple_modules.v
> synth -top multiple_modules
> abc -liberty lib/sky....lib
> show

```
# synth -top multiple_modules output:

![Multiple_Modules](images/synth-top-mult-modules.png)

- Inferred sub-module1 has 1 AND gate.
- Inferred sub-module2 has 1 OR gate.
- Top module has sub-module 1 and 2 instances.

# abc -liberty lib/sky...lib output:

![Multiple_Modules - abc output](images/mult-modules-abc.png)

```
> show multiple_modules
```
![Multiple_Modules - abc output after show command](images/mult-modules-abc-show.png)

- Interestingly , it does not show AND and OR gate but shows as u1 and u2 which are the instantiations. This is called Hierarchial design!!
```
> write_verilog multiple_modules_hier.v
> exit
> vim/gvim multiple_modules_hier.v
```
# multiple_modules_hier.v

```
/* Generated by Yosys 0.53 (git sha1 53c22ab7c0ced80861c7536c5dae682c30fb5834, clang++ 17.0.0 -fPIC -O3) */

(* top =  1  *)
(* src = "verilog_files/multiple_modules.v:10.1-14.10" *)
module multiple_modules(a, b, c, y);
  (* src = "verilog_files/multiple_modules.v:10.32-10.33" *)
  input a;
  wire a;
  (* src = "verilog_files/multiple_modules.v:10.41-10.42" *)
  input b;
  wire b;
  (* src = "verilog_files/multiple_modules.v:10.50-10.51" *)
  input c;
  wire c;
  (* src = "verilog_files/multiple_modules.v:11.7-11.11" *)
  wire net1;
  (* src = "verilog_files/multiple_modules.v:10.61-10.62" *)
  output y;
  wire y;
  (* module_not_derived = 32'd1 *)
  (* src = "verilog_files/multiple_modules.v:12.14-12.38" *)
  sub_module1 u1 (
    .a(a),
    .b(b),
    .y(net1)
  );
  (* module_not_derived = 32'd1 *)
  (* src = "verilog_files/multiple_modules.v:13.14-13.38" *)
  sub_module2 u2 (
    .a(net1),
    .b(c),
    .y(y)
  );
endmodule

(* src = "verilog_files/multiple_modules.v:5.1-7.10" *)
module sub_module1(a, b, y);
  (* src = "verilog_files/multiple_modules.v:5.27-5.28" *)
  wire _0_;
  (* src = "verilog_files/multiple_modules.v:5.36-5.37" *)
  wire _1_;
  (* src = "verilog_files/multiple_modules.v:5.46-5.47" *)
  wire _2_;
  (* src = "verilog_files/multiple_modules.v:5.27-5.28" *)
  input a;
  wire a;
  (* src = "verilog_files/multiple_modules.v:5.36-5.37" *)
  input b;
  wire b;
  (* src = "verilog_files/multiple_modules.v:5.46-5.47" *)
  output y;
  wire y;
  sky130_fd_sc_hd__and2_0 _3_ (
    .A(_1_),
    .B(_0_),
    .X(_2_)
  );
  assign _1_ = b;
  assign _0_ = a;
  assign y = _2_;
endmodule

(* src = "verilog_files/multiple_modules.v:1.1-3.10" *)
module sub_module2(a, b, y);
  (* src = "verilog_files/multiple_modules.v:1.27-1.28" *)
  wire _0_;
  (* src = "verilog_files/multiple_modules.v:1.36-1.37" *)
  wire _1_;
  (* src = "verilog_files/multiple_modules.v:1.46-1.47" *)
  wire _2_;
  (* src = "verilog_files/multiple_modules.v:1.27-1.28" *)
  input a;
  wire a;
  (* src = "verilog_files/multiple_modules.v:1.36-1.37" *)
  input b;
  wire b;
  (* src = "verilog_files/multiple_modules.v:1.46-1.47" *)
  output y;
  wire y;
  sky130_fd_sc_hd__or2_0 _3_ (
    .A(_1_),
    .B(_0_),
    .X(_2_)
  );
  assign _1_ = b;
  assign _0_ = a;
  assign y = _2_;
endmodule

```

```
> write_verilog -noattr multiple_modules_hier.v
> exit
> vim/gvim multiple_modules_hier.v
```

# multiple_modules_hier.v ( with -noattr)

![Multiple_Modules - Hier](images/mult-modules-hier.png)

![Multiple_Modules - Hier](images/mult-modules-hier-exp.png)

- NAND Gate = Stacked N-MOS + Parellel P-MOS
- NOR Gate = Stacked P-MOS + Parellel N-MOS
- STACKED P-MOS = BAD!! (P-MOS has poor mobility and to improve this , we need to use wider transistors).

# Flattened netlist 

```
> flatten
> write_verilog multiple_modules_flat.v
> exit
> vim/gvim verilog_files/multiple_modules_flat.v

```
# multiple_modules_flat.v

![Multiple_Modules - Flat](images/mult-modules-flat.png)

- Direct instantiation of OR and AND gate is found and there is no u1 and u2 instantiation just like in hierarchial!

![Multiple_Modules - Flat output](images/mult-modules-flat-exp.png)

# Sub-Module Level Synthesis

```
> yosys
> read_liberty -lib lib/sky....lib
> read_verilog verilog_files/multiple_modules.v
> synth -top sub_module1
> abc -liberty lib/sky...lib
> show
  ```
![Sub-Module Synthesis output](images/sub-module-synth.png)

![Sub-Module Synthesis output- show command](images/sub-module-synth-show.png)

- sub module 1 alone will be seen but not the other modules.

# Why sub-module level synthesis?

- Preferred when we have multiple instances of the same module.
- When we want to do divide and conquer approach ( Design is massive and tool not able to do its job.)

### Various Flop Coding Styles and optimization

- How to code a flop / Different coding styles for flops
- Files location : verilog_files/ff.v

# Why flops?
- When input is given to a combinational circuit, ouput is going to change after a propagation delay.
- Propagatio delay = glitch

  ![GLITCH](images/why-flops-glitch.png)

- In the above example , a and b are inputs of AND gate with a delay of 2 ns and i0 is the output wire of a and b. i0 is OR-ed with c input with a delay of 1ns. The waveform depicts the difference of 1 ns(momentarily y , the output goes low) which is called a GLITCH.

- More combinationa circuits , more glitchy which is evident from above example.
- To avoid glitches , we need a memory element that can store the value , which are called FLOPS.
- Flop output changes only on the edge of the clock (even if inputs are glitchy , output will be stable).

# How to code a Flop?

Note: Initialize the flop (reset or set which can be either synchronous or asynchronous)

  ![DFF with sync/async reset](images/dff-synch-asynch.png)

1. Flop with asynchronous (does not wait/irrespective of a clock) reset [`dff_asyncres.v`](./dff_asyncres.v)
2. Flop with asynchronous (does not wait/irrespective of a clock) set   [`dff_asyncset.v`](./dff_asyncset.v)
3. Flop with synchronous (does not wait/irrespective of a clock) reset  [`dff_synch.v`](./dff_synch.v)
4. Flop with synchronous and asynchronous reset  [`dff_synch_asynch.v`](./dff_synch_asynch.v)

# Synthesis of Flops

```
> yosys
> read_liberty -lib lib.sky...lib
> read_verilog dff_asyncres.v tb_dff_ayncres.v
> synth -top dff_ayncres
> dfflibmap -liberty lib/sky...lib (looks only for dff)
> abc -liberty lib/sky...lib
> show

```
 ![DFF with async reset - show](images/async-show.png)

 # Interesting optimization

- Files : mult_2.v and mult_8.v
- Case - mult_2.v
```
module mult_2 (input [2:0] a , output [3:0} y);
assign y = a*2;
endmodule
```
 ![Mult-2](images/mult-2.png)  

 - We come to know that:
- (any number) * 2 = the number appended with one 0.
- (any number) * 4 = the number appended with two 0s.
- (any number) * 8 = the number appended with three 0s.

# Result in synthesizer:
- No cells will be synthesized and it can be inferred from the output.

```
> yosys
.
.
.
```
![Mult-2 synthesized output](images/mult-2-synth.png)

- Taking another example in mind:
```
module mult8 (input [2:0] a , output [5:0] y);
assign y = 9 * a;
endmodule
```  
![Mult-8 Concept](images/mult-8.png)

- We also have the netlist below:

![Mult-8 Netlist](images/mult-8-netlist.png)

---

## Day 3

### Introduction to optimizations

### Combinational logic optimizations

### Sequential logic optimizations

### Sequential optimizations for unused outputs

---

## Day 4

### GLS, Synthesis-Simulation mismatch and Blocking/Non-blocking statements

### Labs on GLS and Synthesis-Simulation Mismatch

### Labs on synth-sim mismatch for blocking statements

---

## Day 5

### If Case constructs

### Labs on "Incomplete If Case"

### Labs on "Incomplete overlapping Case"

### for loop and for generate

### Labs on "for loop" and "for generate"




